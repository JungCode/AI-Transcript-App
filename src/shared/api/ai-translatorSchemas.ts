/**
 * Generated by orval v7.14.0 ðŸº
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { apiClient } from './apiClient';
export interface EpisodeCreate {
  episode_id: number;
  audio_url: string;
}

export type EpisodeReadId = number | null;

export type EpisodeReadTranscriptData = { [key: string]: unknown };

export type EpisodeReadLanguage = string | null;

export type EpisodeReadType = string | null;

export interface EpisodeRead {
  episode_id: number;
  id?: EpisodeReadId;
  user_id: number;
  transcript_data: EpisodeReadTranscriptData;
  language?: EpisodeReadLanguage;
  progress: number;
  type?: EpisodeReadType;
  status: Status;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface SentenceTranslationRead {
  translated_sentence: string;
}

export type Status = (typeof Status)[keyof typeof Status];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Status = {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed',
} as const;

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface WordTranslationRead {
  word: string;
  translated_word: string;
  detail: string;
  word_type: string;
  phonetic: string;
}

/**
 * @summary Health
 */
export const healthHealthGet = (signal?: AbortSignal) => {
  return apiClient<unknown>({ url: `/ai-translator/health`, method: 'GET', signal });
};

export const getHealthHealthGetQueryKey = () => {
  return [`/health`] as const;
};

export const getHealthHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof healthHealthGet>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthHealthGet>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthHealthGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthHealthGet>>> = ({
    signal,
  }) => healthHealthGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthHealthGet>>
>;
export type HealthHealthGetQueryError = unknown;

export function useHealthHealthGet<
  TData = Awaited<ReturnType<typeof healthHealthGet>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthHealthGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthHealthGet<
  TData = Awaited<ReturnType<typeof healthHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthHealthGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthHealthGet<
  TData = Awaited<ReturnType<typeof healthHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthHealthGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Health
 */

export function useHealthHealthGet<
  TData = Awaited<ReturnType<typeof healthHealthGet>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof healthHealthGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthHealthGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create Transcript
 */
export const createTranscriptTranscriptsPost = (
  episodeCreate: EpisodeCreate,
  signal?: AbortSignal,
) => {
  return apiClient<unknown>({
    url: `/ai-translator/transcripts`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: episodeCreate,
    signal,
  });
};

export const getCreateTranscriptTranscriptsPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTranscriptTranscriptsPost>>,
    TError,
    { data: EpisodeCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTranscriptTranscriptsPost>>,
  TError,
  { data: EpisodeCreate },
  TContext
> => {
  const mutationKey = ['createTranscriptTranscriptsPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTranscriptTranscriptsPost>>,
    { data: EpisodeCreate }
  > = props => {
    const { data } = props ?? {};

    return createTranscriptTranscriptsPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTranscriptTranscriptsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTranscriptTranscriptsPost>>
>;
export type CreateTranscriptTranscriptsPostMutationBody = EpisodeCreate;
export type CreateTranscriptTranscriptsPostMutationError = HTTPValidationError;

/**
 * @summary Create Transcript
 */
export const useCreateTranscriptTranscriptsPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTranscriptTranscriptsPost>>,
      TError,
      { data: EpisodeCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTranscriptTranscriptsPost>>,
  TError,
  { data: EpisodeCreate },
  TContext
> => {
  const mutationOptions =
    getCreateTranscriptTranscriptsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get Transcription
 */
export const getTranscriptionTranscriptEpisodeIdGet = (
  episodeId: number,
  signal?: AbortSignal,
) => {
  return apiClient<EpisodeRead>({
    url: `/transcript/${episodeId}`,
    method: 'GET',
    signal,
  });
};

export const getGetTranscriptionTranscriptEpisodeIdGetQueryKey = (
  episodeId?: number,
) => {
  return [`/transcript/${episodeId}`] as const;
};

export const getGetTranscriptionTranscriptEpisodeIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
  TError = HTTPValidationError,
>(
  episodeId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetTranscriptionTranscriptEpisodeIdGetQueryKey(episodeId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>
  > = ({ signal }) => getTranscriptionTranscriptEpisodeIdGet(episodeId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!episodeId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTranscriptionTranscriptEpisodeIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>
>;
export type GetTranscriptionTranscriptEpisodeIdGetQueryError =
  HTTPValidationError;

export function useGetTranscriptionTranscriptEpisodeIdGet<
  TData = Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
  TError = HTTPValidationError,
>(
  episodeId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTranscriptionTranscriptEpisodeIdGet<
  TData = Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
  TError = HTTPValidationError,
>(
  episodeId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTranscriptionTranscriptEpisodeIdGet<
  TData = Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
  TError = HTTPValidationError,
>(
  episodeId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Transcription
 */

export function useGetTranscriptionTranscriptEpisodeIdGet<
  TData = Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
  TError = HTTPValidationError,
>(
  episodeId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTranscriptionTranscriptEpisodeIdGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTranscriptionTranscriptEpisodeIdGetQueryOptions(
    episodeId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Translate Word
 */
export const translateWordTranslateWordWordSentenceGet = (
  word: string,
  sentence: string,
  signal?: AbortSignal,
) => {
  return apiClient<WordTranslationRead>({
    url: `/translate/word/${word}/${sentence}`,
    method: 'GET',
    signal,
  });
};

export const getTranslateWordTranslateWordWordSentenceGetQueryKey = (
  word?: string,
  sentence?: string,
) => {
  return [`/translate/word/${word}/${sentence}`] as const;
};

export const getTranslateWordTranslateWordWordSentenceGetQueryOptions = <
  TData = Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
  TError = HTTPValidationError,
>(
  word: string,
  sentence: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTranslateWordTranslateWordWordSentenceGetQueryKey(word, sentence);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>
  > = ({ signal }) =>
    translateWordTranslateWordWordSentenceGet(word, sentence, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(word && sentence),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TranslateWordTranslateWordWordSentenceGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>
>;
export type TranslateWordTranslateWordWordSentenceGetQueryError =
  HTTPValidationError;

export function useTranslateWordTranslateWordWordSentenceGet<
  TData = Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
  TError = HTTPValidationError,
>(
  word: string,
  sentence: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
          TError,
          Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTranslateWordTranslateWordWordSentenceGet<
  TData = Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
  TError = HTTPValidationError,
>(
  word: string,
  sentence: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
          TError,
          Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTranslateWordTranslateWordWordSentenceGet<
  TData = Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
  TError = HTTPValidationError,
>(
  word: string,
  sentence: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Translate Word
 */

export function useTranslateWordTranslateWordWordSentenceGet<
  TData = Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
  TError = HTTPValidationError,
>(
  word: string,
  sentence: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof translateWordTranslateWordWordSentenceGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getTranslateWordTranslateWordWordSentenceGetQueryOptions(
    word,
    sentence,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Translate Sentence
 */
export const translateSentenceTranslateSentenceSentenceGet = (
  sentence: string,
  signal?: AbortSignal,
) => {
  return apiClient<SentenceTranslationRead>({
    url: `/translate/sentence/${sentence}`,
    method: 'GET',
    signal,
  });
};

export const getTranslateSentenceTranslateSentenceSentenceGetQueryKey = (
  sentence?: string,
) => {
  return [`/translate/sentence/${sentence}`] as const;
};

export const getTranslateSentenceTranslateSentenceSentenceGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
  >,
  TError = HTTPValidationError,
>(
  sentence: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getTranslateSentenceTranslateSentenceSentenceGetQueryKey(sentence);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>>
  > = ({ signal }) =>
    translateSentenceTranslateSentenceSentenceGet(sentence, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!sentence,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TranslateSentenceTranslateSentenceSentenceGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>>
  >;
export type TranslateSentenceTranslateSentenceSentenceGetQueryError =
  HTTPValidationError;

export function useTranslateSentenceTranslateSentenceSentenceGet<
  TData = Awaited<
    ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
  >,
  TError = HTTPValidationError,
>(
  sentence: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
          >
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTranslateSentenceTranslateSentenceSentenceGet<
  TData = Awaited<
    ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
  >,
  TError = HTTPValidationError,
>(
  sentence: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
          >
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTranslateSentenceTranslateSentenceSentenceGet<
  TData = Awaited<
    ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
  >,
  TError = HTTPValidationError,
>(
  sentence: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Translate Sentence
 */

export function useTranslateSentenceTranslateSentenceSentenceGet<
  TData = Awaited<
    ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
  >,
  TError = HTTPValidationError,
>(
  sentence: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof translateSentenceTranslateSentenceSentenceGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getTranslateSentenceTranslateSentenceSentenceGetQueryOptions(
      sentence,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Stream Transcript Progress
 */
export const streamTranscriptProgressTranscriptStreamTranscriptIdGet = (
  transcriptId: number,
  signal?: AbortSignal,
) => {
  return apiClient<unknown>({
    url: `/transcript/stream/${transcriptId}`,
    method: 'GET',
    signal,
  });
};

export const getStreamTranscriptProgressTranscriptStreamTranscriptIdGetQueryKey =
  (transcriptId?: number) => {
    return [`/transcript/stream/${transcriptId}`] as const;
  };

export const getStreamTranscriptProgressTranscriptStreamTranscriptIdGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet>
    >,
    TError = HTTPValidationError,
  >(
    transcriptId: number,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet
            >
          >,
          TError,
          TData
        >
      >;
    },
  ) => {
    const { query: queryOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getStreamTranscriptProgressTranscriptStreamTranscriptIdGetQueryKey(
        transcriptId,
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet
        >
      >
    > = ({ signal }) =>
      streamTranscriptProgressTranscriptStreamTranscriptIdGet(
        transcriptId,
        signal,
      );

    return {
      queryKey,
      queryFn,
      enabled: !!transcriptId,
      ...queryOptions,
    } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type StreamTranscriptProgressTranscriptStreamTranscriptIdGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet>
    >
  >;
export type StreamTranscriptProgressTranscriptStreamTranscriptIdGetQueryError =
  HTTPValidationError;

export function useStreamTranscriptProgressTranscriptStreamTranscriptIdGet<
  TData = Awaited<
    ReturnType<typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet>
  >,
  TError = HTTPValidationError,
>(
  transcriptId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet
            >
          >
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStreamTranscriptProgressTranscriptStreamTranscriptIdGet<
  TData = Awaited<
    ReturnType<typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet>
  >,
  TError = HTTPValidationError,
>(
  transcriptId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet
            >
          >
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStreamTranscriptProgressTranscriptStreamTranscriptIdGet<
  TData = Awaited<
    ReturnType<typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet>
  >,
  TError = HTTPValidationError,
>(
  transcriptId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Stream Transcript Progress
 */

export function useStreamTranscriptProgressTranscriptStreamTranscriptIdGet<
  TData = Awaited<
    ReturnType<typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet>
  >,
  TError = HTTPValidationError,
>(
  transcriptId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof streamTranscriptProgressTranscriptStreamTranscriptIdGet
          >
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getStreamTranscriptProgressTranscriptStreamTranscriptIdGetQueryOptions(
      transcriptId,
      options,
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
